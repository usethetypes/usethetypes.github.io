<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">
  <link href="favicon.ico" rel="icon">
  <title>usethetypes#2</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.2/css/bootstrap.min.css" rel="stylesheet">
  <link href="default.css" rel="stylesheet">
</head>

<body class="transcript">

  <div class="cover-container d-flex w-100 h-100 p-3 mx-auto flex-column">
    <header class="masthead mb-auto">
      <div class="inner">
        <h3 class="masthead-brand">usethetypes.com</h3>
        <nav class="nav nav-masthead justify-content-center">
          <a class="nav-link" href="index.html">Home</a>
          <a class="nav-link" href="features.html">Features</a>
          <a class="nav-link" href="contact.html">Contact</a>
        </nav>
      </div>
    </header>

    <main role="main" class="inner cover">
      <h2>usethetypes#2: Your First Snap App</h2>

      <p>
        <a href="https://youtu.be/_C3QsKF4UQI">Watch video in YouTube</a>
      </p>
      <p>
        <a href="https://github.com/usethetypes/usethetypes-002-your-first-snap-app">Source code in GitHub</a>
      </p>

      <p class="lead">
        Now you have working Haskell Stack and VSCode installations, we can
          create our first <a href="http://snapframework.com/">Snap</a>
          application in Haskell. This application will show you how to respond
          to the top-level route and how to use alternation to handle named
          routes as well as a default route.
      </p>

      <h3>Step 1: Create starter project</h3>
<pre>
stack new snap-hello-world simple --resolver=lts-12.0
cd snap-hello-world
git init
echo /.stack-work/ >> .gitignore
git add .
stack build --fast
stack exec snap-hello-world
git commit -m "Step 1: Create starter project"
</pre>

      <h3>Step 2: Add Snap dependencies</h3>
      <p>
        Let's start a build loop:
      </p>
<pre>
stack build --fast --file-watch
</pre>
      <p>
        Now we can see the results of our changes as they are saved.
      </p>

      <p>
        Next, add <tt>snap-core</tt> and <tt>snap-server</tt> to the
        <tt>build-depends</tt> section of your your .cabal file.
      </p>
<pre>
stack build --fast
git add .
git commit -m "Step 2: Add Snap dependencies"
</pre>

      <h3>Step 3: Return "Hello World"</h3>
<pre>
{-# LANGUAGE OverloadedStrings #-}
  
module Main (main) where

import Snap.Core (ifTop, writeText)
import Snap.Http.Server (quickHttpServe)

main :: IO ()
main = quickHttpServe $ ifTop (writeText "Hello world")
</pre>

      <p>
        This makes use of three Snap functions:
      </p>
      <ul>
        <li><tt>ifTop</tt></li>
        <li><tt>writeText</tt></li>
        <li><tt>quickHttpServe</tt></li>
      </ul>

      <p>
        It also uses a very commonly used language extension, namely
        <tt>OverloadedStrings</tt>.
      </p>
<pre>
stack build --fast --exec snap-hello-world
git add .
git commit -m "Step 3: Return \"Hello World\""
</pre>

      <p>
        Open up your browser and navigate to <tt>http://localhost:8000</tt>.
      </p>

      <p>
        Voil&agrave;&mdash;we have pretty much the simplest possible web site in
        about five lines of Haskell.
      </p>

      <p>
        Also try out <tt>http://localhost:8000/foo.html</tt>. This errors out.
        This is because the application explicitly handles only the top-level
        route using <tt>ifTop</tt>.
      </p>

      <h3>Step 4: Clean up</h3>
      <p>
        Let's go back and address the warning we see when we run the program:
      </p>
<pre>
stack exec snap-hello-world
</pre>

      <p>
        What we're seeing is a function of the default configuration used by
        <tt>quickHttpServe</tt>: it expects a <tt>log</tt> directory under the
        current directory in order to log to. Let's create such a directory and
        ignore it in Git:
      </p>
<pre>
mkdir log
touch log/.keep
git add log/.keep
echo /log/ >> .gitignore
stack exec snap-hello-world
git status
git diff
git add .
git commit -m "Step 4: Clean up"
</pre>

      <p>
        Note that this is relative to the current working directory. Thus if you
        run <tt>snap-hello-world</tt> in a subdirectory, the program will expect
        a <tt>log</tt> directory there instead. Most likely as the program
        develops in sophistication, you'll end up logging to a location
        determined by an environment variable or command-line option. We'll
        explore this kind of configuration in later videos.
      </p>

      <h3>Step 5: Handle all routes indiscriminately</h3>
      
      In `src/Main.hs`:
      
      ```
      {-# LANGUAGE OverloadedStrings #-}
      
      module Main (main) where
      
      import Snap.Core (writeText)
      import Snap.Http.Server (quickHttpServe)
      
      main :: IO ()
      main = quickHttpServe $ writeText "Hello world"
      ```
      
      Check out a few examples:
      
      * `http://localhost:8000`
      * `http://localhost:8000/foo.html`
      * `http://localhost:8000/bar.html`
      
      ## Step 6: Alternation
      
      Originally, we responded to only the top-level route using `ifTop` and errored out for everything else. Then we removed this restrictions to return "Hello World" for all paths. Let's add an alternative route:
      
      Update `src/Main.hs` to look like the following:
      
      ```
      {-# LANGUAGE OverloadedStrings #-}
      
      module Main (main) where
      
      import Control.Applicative ((<|>))
      import Snap.Core (ifTop, writeText)
      import Snap.Http.Server (quickHttpServe)
      
      main :: IO ()
      main = quickHttpServe $
          ifTop (writeText "Hello world")
          <|> writeText "Bad path"
      ```
      
      Now we're using `ifTop` again plus `<|>` to provide alternatives. Snap will evaluate the path conditions in the order they're defined. `ifTop` matches `/` while the last `writeText "Bad path"` matches anything not already matched.
      
      ## Step 7: Matching paths
      
      ```
      {-# LANGUAGE OverloadedStrings #-}
      
      module Main (main) where
      
      import Control.Applicative ((<|>))
      import Snap.Core (ifTop, route, writeText)
      import Snap.Http.Server (quickHttpServe)
      
      main :: IO ()
      main = quickHttpServe $
          ifTop (writeText "Hello world")
          <|> route [ ("/ping", writeText "Ping") ]
          <|> writeText "Bad path"
      ```
      
      `route` allows us to provide a list of zero or more "named" paths.
      
      ## Conclusions
      
      You've created your first Snap app. You can build, run it and test it in your browser.

    <footer class="mastfoot mt-auto">
      <div class="inner">
        <p>&copy; 2018 usethetypes.com</p>
      </div>
    </footer>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/popper.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.2/js/bootstrap.min.js"></script>
</body>
</html>
